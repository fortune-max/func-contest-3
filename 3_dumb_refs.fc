{-
  Contract receives internal message with text comment (https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages) which contains algebraic equation containing numbers in decimal representation and operations `(+-*/)`.
  All values (including intermediate) fit 256 bit. Contract should respond (coins = 0, mode = 64) with correct answer encoded as text comment back.
  It is guaranteed that all tests contain a valid algebraic equations.
  Division result should be rounded down. It is guaranteed that tests do not contain division by zero.
-}

int get_total_bits (slice sl) {
  int ans = slice_bits(sl);
  while (slice_refs(sl)) {
    sl = (sl~load_ref()).begin_parse();
    ans += slice_bits(sl);
  }
  return ans;
}

slice get_slice(slice sl, int start_idx, int bit_count){
  int bit_count_dup = bit_count;
  int slice_first_idx = 0;
  int slice_last_idx = slice_bits(sl) - 1;
  while ((start_idx > slice_last_idx) & (slice_refs(sl) > 0)) {
    sl = (sl~load_ref()).begin_parse();
    slice_first_idx = slice_last_idx + 1;
    slice_last_idx += slice_bits(sl);
  }
  builder b = begin_cell();
  sl~load_uint(start_idx - slice_first_idx);  ;; might be unsafe
  while (bit_count & (slice_bits(sl) > 0)){
    int to_take = min(slice_bits(sl), bit_count);
    b~store_uint(sl~load_uint(to_take), to_take);
    bit_count -= to_take;
    if ((bit_count > 0) & (slice_refs(sl))) {
      sl = (sl~load_ref()).begin_parse();
    }
  }
  slice ans = b.end_cell().begin_parse();
  return ans;
}

int get_uint(slice sl, int start_idx, int bit_count){
  slice ans = get_slice(sl, start_idx, bit_count);
  return ans~load_uint(slice_bits(ans));
}

(int, int) tointeger(int num) inline {
  (int ans, int multiplier, int bits, int is_negative) = (0, 1, 0, 0);
  if (num < 0) {
    is_negative = -1; num *= -1;
  }
  do {
    int digit = num % 10;
    num /= 10;
    ans += multiplier * (digit + 48);
    bits += 8;
    multiplier *= 256;
  } until (num == 0);
  if (is_negative) {
    bits += 8; ans += multiplier * 45;     ;; add -ve sign
  }
  return (ans, bits);
}

;; expects at least 1 digit (8-bit) in slice
(int, int) nxt_num(slice sl, int bits_left) {
  (int num, int bits_done) = (0, 0);
  while (bits_left) {
    int hint = sl~load_uint(8);
    if ((hint >= 48) & (hint <= 57)){
      bits_done += 8; bits_left -= 8;
      num = 10 * num + (hint - 48);
    } else {
      bits_left = 0;
    }
  }
  return (num, bits_done);
}

int perform_op (int left, int right, int sign) {
  if (sign == 43){
    return left + right;
  } elseif (sign == 47) {
    return left / right;
  } elseif (sign == 42) {
    return left * right;
  } else {
    return left - right;
  }
}

(int, int) mul_div (slice sl, int bits_left, int bits_done, slice in_msg_body);

;; NUM ), +/*-) ; (, ( NUM ; +/*-, ( NUM

;; must start with a bracket if subseq run, which must contain at least one integer
;; may end with eof or )
(int, int) brackets (slice sl, int bits_left, int bits_done, int first_run, slice in_msg_body) {
  if (~ first_run){
    bits_done += 8; bits_left -= 8;   ;; RM first bracket
  }
  (int ans, int processed, int sign, int hint) = (0, 0, 43, -1);
  do {
    (int sub_calc, processed) = mul_div(get_slice(in_msg_body, bits_done, 300), bits_left, bits_done, in_msg_body);
    bits_left -= processed - bits_done; bits_done = processed;
    ans = perform_op(ans, sub_calc, sign);
    if (bits_left >= 8) {
      hint = get_uint(in_msg_body, bits_done, 8);
      if (hint == 41) {   ;; met end of bracket
        bits_done += 8; bits_left = 0;
      } else {
        sign = hint;
        bits_done += 8; bits_left -= 8;
      }
    }
  } until (bits_left == 0);
  return (ans, bits_done);
}

;; expects at least 1 digit in slice. Proceeds execution till + or - or eof met
(int, int) mul_div (slice sl, int bits_left, int bits_done, slice in_msg_body) {
  (int ans, int processed) = (-1, 0);
  int hint = get_uint(in_msg_body, bits_done, 8);
  if (hint == 40) {     ;; left_bracket after + or - sign
    (ans, processed) = brackets(get_slice(in_msg_body, bits_done, 300), bits_left, bits_done, 0, in_msg_body);
    bits_left -= processed - bits_done; bits_done = processed;
  } else {              ;; NUM after + or - sign
    (ans, processed) = nxt_num(get_slice(in_msg_body, bits_done, 300), bits_left);
    bits_done += processed; bits_left -= processed;
  }

  while (bits_left >= 8) {
    hint = get_uint(in_msg_body, bits_done, 8);
    if ((hint == 41) | (hint == 43) | (hint == 45)) {   ;; right_bracket, + or - after NUM
      bits_left = 0;
    } else {                                  ;; * or / sign after NUM or right_bracket
      int sign = hint;
      bits_done += 8; bits_left -= 8;
      hint = get_uint(in_msg_body, bits_done, 8);
      if (hint == 40) {       ;; left_bracket after sign
        (int sub_calc, processed) = brackets(get_slice(in_msg_body, bits_done, 300), bits_left, bits_done, 0, in_msg_body);
        bits_left -= processed - bits_done; bits_done = processed;
        ans = perform_op(ans, sub_calc, sign);
      } else {                ;; NUM after sign
        (int sub_calc, processed) = nxt_num(get_slice(in_msg_body, bits_done, 300), bits_left);
        bits_done += processed; bits_left -= processed;
        ans = perform_op(ans, sub_calc, sign);
      }
    }
  }
  return (ans, bits_done);
}

;; testable
() recv_internal (cell message, slice in_msg_body) {
  slice sl = message.begin_parse();
  int flags = sl~load_uint(4); ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
  slice sender_address = sl~load_msg_addr();

  in_msg_body~load_uint(32);
  (int ans, int bits) = brackets(in_msg_body, get_total_bits(in_msg_body), 0, -1, in_msg_body);
  (int integer_rep, bits) = tointeger(ans);

  cell response_message_body = begin_cell()
    .store_uint(0, 32)  ;; op_code 0, simple message with comment;
    .store_uint(integer_rep, bits)  ;; ans in ascii hex
    .end_cell();
  
  cell response_msg = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(sender_address)  ;; addr dest
    .store_grams(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 0)
    .store_uint(1, 1)
    .store_ref(response_message_body)
    .end_cell();

  send_raw_message(response_msg, 64);
}

(int, int) fme (int a, int b) method_id {
  ;; cell msg = begin_cell().store_uint(16393665708263953322375373876328806561833, 136).end_cell();     ;; -3 -9 = -12
  cell msg = begin_cell().store_uint(21049533804892064848820853960209038218164457837627546297113849145, 216).end_cell();     ;; -3 -9 = -12
  slice sl = msg.begin_parse();
  ;;~dump([get_slice(sl, 56, 80), get_slice(sl, 32, 8)]);
  (int ans, int bits) = brackets(sl,get_total_bits(sl), 0, -1, sl);
  ~dump([911, ans]);
  ;; (int integer_rep, _) = tointeger(ans);
  ;; ~dump(integer_rep);
  return (3, 4);
}
