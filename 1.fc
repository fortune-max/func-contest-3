{-
  In TON there is a limit on the size of the external message which can be sent equal to 64 kB. Sometimes it is necessary to send a larger
   message; it requires the onchain construction of one message from multiple smaller parts. Your task is to create such construction contract.
  In particular, a contestant needs to develop a FunC contract with two features:
    a) it has get_method "decomposite" for decomposition of large cell to parts: it accepts 1 cell (number_of_bits<1000000, 
    number_of_cells<4000 , depth<256) and 1 address and returns tuple of cells (each of which has less than 1000 distinct cells
     and 40000 bits total), those cells will be transformed to slice and sent as internal message body to the contract.
    b) recv_internal should handle those internal messages from get-method described above and upon receiving last one, send 
    initial large cell to the address (coins amount 0, mode 0). For simplicity, it is guaranteed that messages will be sent 
    exactly in the order in which they were in decomposite output and no other messages will be sent in between.
  Note, that initial state of contract storage will be empty cell: cell with zero bits and refs.
-}

tuple store_address_to_tupleidx_and_hash(builder curr_address, int hash_key, int tuple_idx, tuple final_result){
  slice curr_address_sl = curr_address.end_cell().begin_parse();
  int addr_int_rep = curr_address_sl~load_uint(slice_bits(curr_address_sl));
  cell addr_map = final_result.at(0);
  addr_map~udict_set(256, addr_int_rep, begin_cell().store_uint(tuple_idx, 8).store_uint(hash_key, 256).end_cell().begin_parse());
  tuple updated_tuple = empty_tuple(); updated_tuple~tpush(addr_map); int ct = 1;
  while (ct < 255){
    updated_tuple~tpush(final_result.at(ct)); ct += 1;
  }
  return updated_tuple;
}

(int, tuple) store_key_to_slice(int hash_key, slice slice_to_add, int tuple_idx_hint, tuple final_result){
  cell cell_cand = final_result.at(tuple_idx_hint);
  (cell cell_stats, _) = udict_get_ref?(cell_cand, 256, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  slice cell_stats_sl = cell_stats.begin_parse();
  int bit_ct = cell_stats_sl~load_uint(16);   ;; max 40,000 (max container 65535)
  int cell_ct = cell_stats_sl~load_uint(10);  ;; max 1,000 cells (max container 1023)
  int verified_full = cell_stats_sl~load_uint(1);   ;; boolean (uint 0 or 1)
  int tuple_idx = tuple_idx_hint;
  if ((bit_ct >= 37500) | (cell_ct >= 995)) {
    ;; this cell probably near full, confirm, then switch
    (int compute_cell_ct, int compute_bits_ct, int compute_ref_ct) = compute_data_size(cell_cand, 1000);
    if ((compute_bits_ct >= 37500) | (compute_cell_ct >= 995)){
      ;; this cell is definitely full, switch
      verified_full = 1; tuple_idx_hint += 1;
      (tuple_idx, final_result) = store_key_to_slice(hash_key, slice_to_add, tuple_idx_hint, final_result);
    } else { 
      ;; we ok bruh, do your thing
      int slice_bit_ct = slice_bits(slice_to_add); bit_ct += slice_bit_ct; cell_ct += 1;
      cell_cand~udict_set_ref(256, hash_key, begin_cell().store_slice(slice_to_add~load_bits(slice_bit_ct)).end_cell());
    }
  } else {
    ;; this cell is definitely able to take new cell, no need to check
    int slice_bit_ct = slice_bits(slice_to_add); bit_ct += slice_bit_ct; cell_ct += 1;
    cell_cand~udict_set_ref(256, hash_key, begin_cell().store_slice(slice_to_add~load_bits(slice_bit_ct)).end_cell());
  }
  ;; update cell stats
  cell upd_cell_stats = begin_cell().store_uint(bit_ct, 16).store_uint(cell_ct, 10).store_uint(verified_full, 1).end_cell();
  cell_cand~udict_set_ref(256, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, upd_cell_stats);
  ;; replace element in final_result
  int ct = 0; tuple updated_tuple = empty_tuple();
  while (ct < 255){
    if (ct == tuple_idx){
      updated_tuple~tpush(cell_cand);
    } else {
      updated_tuple~tpush(final_result.at(ct));
    } ct += 1;
  }
  return (tuple_idx, updated_tuple);
}

(int, tuple) add_to_tuple(slice slice_to_add, builder curr_address, int tuple_idx_hint, tuple final_result) {
  int slice_bit_ct = slice_bits(slice_to_add); int remainder = slice_bit_ct % 8; slice slice_to_hash = slice_to_add;
  int hash_key = -1;
  if (remainder){
    int MOD = 57896044618658097711785492504343953926634992332820282019728792003956564819949;
    slice slice_prfx = begin_cell().store_uint(0, 8 - remainder).store_slice(slice_to_hash~load_bits(remainder)).end_cell().begin_parse();
    hash_key = (string_hash(slice_prfx) % MOD) + (string_hash(slice_to_hash) % MOD);
  }
  hash_key = string_hash(slice_to_hash);  ;; Hashkey for slice to add
  (int tuple_idx, final_result) = store_key_to_slice(hash_key, slice_to_add, tuple_idx_hint, final_result);
  final_result = store_address_to_tupleidx_and_hash(curr_address, hash_key, tuple_idx, final_result);
  return (tuple_idx, final_result);
}

(int, tuple) cycle_cell(cell curr_cell, builder curr_address, int tuple_idx_hint, tuple final_result){   ;; initialize final_result with stats
  slice curr_cell_slice = curr_cell.begin_parse();    ;; use slice_hash, pad to 8-bit, no refs
  (tuple_idx_hint, final_result) = add_to_tuple(curr_cell_slice, curr_address, tuple_idx_hint, final_result);
  int children_count = slice_refs(curr_cell_slice);
  if (children_count > 0){
    int ct = 0;
    while (ct < children_count) {
      cell child_cell = curr_cell_slice~load_ref();
      builder child_address = curr_address.store_uint(ct, 2);
      (tuple_idx_hint, final_result) = cycle_cell(child_cell, child_address, tuple_idx_hint, final_result);
      ct += 1;
    }
  }
  return (tuple_idx_hint, final_result);
}

(cell, int) cycle_cell_compose(builder curr_address, tuple final_result) {
  cell addr_map = final_result.at(0);
  cell curr_cell = new_dict();
  ;; check if I exist
  slice curr_address_sl = curr_address.end_cell().begin_parse();
  int addr_int_rep = curr_address_sl~load_uint(slice_bits(curr_address_sl));
  (slice hash_tupleidx_info, int curr_exists) = udict_get?(addr_map, 256, addr_int_rep);
  if (curr_exists) {
    int tuple_idx = hash_tupleidx_info~load_uint(8);
    int hash_key = hash_tupleidx_info~load_uint(256);
    cell slice_hash_to_cell_map = final_result.at(tuple_idx);
    (curr_cell, _) = udict_get_ref?(slice_hash_to_cell_map, 256, hash_key);
    builder curr_cell_builder = begin_cell().store_slice(curr_cell.begin_parse());
    int ct = 0;
    while (ct < 4) {
      (cell child, int child_exists) = cycle_cell_compose(curr_address.store_uint(ct, 2), final_result);
      if (child_exists){ curr_cell_builder.store_ref(child); ct -= 1; }
      else { ct = 4; }
    }
    curr_cell = curr_cell_builder.end_cell();
  }
  return (curr_cell, curr_exists);
}

cell compose(tuple final_results){
  (cell large_cell, _) = cycle_cell_compose(begin_cell().store_uint(0, 2), final_results);
  return large_cell;
}

;; testable
tuple decomposite (cell big_cell, slice destination_address) impure method_id {
  tuple final_result = empty_tuple();
  cell addr_map = new_dict();
  addr_map~udict_set(256, 2, destination_address);  ;; placeholder key-val in dict to init addr_map as cell
  final_result~tpush(addr_map);
  cell init_cell_stats = begin_cell().store_uint(0, 16).store_uint(1, 10).store_uint(0, 1).end_cell(); int ct = 1;
  while (ct < 255){
    ct += 1; cell hash_to_slice_map = new_dict();
    hash_to_slice_map~udict_set_ref(256, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, init_cell_stats);
    final_result~tpush(hash_to_slice_map);
  }
  (int tuple_idx_hint, final_result) = cycle_cell(big_cell, begin_cell().store_uint(3, 2), 1, final_result);
  ;; todo send final_result to dest addr
  return final_result;
}

;; testable
() recv_internal (slice body) {

}

() enumerate_dict(cell my_dict) impure {
  int start_key = 0; int success = -1;
  while (success){
    (start_key, slice content, success) = udict_get_next?(my_dict, 256, start_key);
    ~dump([start_key, content]);
  }
}

(int, int) fme (int a, int b) method_id {
  cell msg = begin_cell().store_uint(57, 8).store_ref( ;; 9
    begin_cell().store_uint(43, 8).store_ref(   ;; +
      begin_cell().store_uint(40, 8).store_ref(   ;; (
        begin_cell().store_uint(51, 8).store_ref( ;; 3
          begin_cell().store_uint(45, 8).store_ref( ;; -
            begin_cell().store_uint(55, 8).store_ref(   ;; 7
              begin_cell().store_uint(41, 8).store_ref(   ;; )
                begin_cell().store_uint(42, 8).store_ref(   ;; *
                  begin_cell().store_uint(53, 8).end_cell()   ;; 5
                ).end_cell()
              ).end_cell()
            ).end_cell()
          ).end_cell()
        ).end_cell()
      ).end_cell()
    ).end_cell()
  ).end_cell();
  tuple results = decomposite(msg, begin_cell().store_uint(8, 8).end_cell().begin_parse());
  cell fme_dict = new_dict();
  slice dummy_slice = begin_cell().store_uint(8, 8).end_cell().begin_parse();
  ~dump(fme_dict);
  fme_dict~udict_set(256, 201, dummy_slice);
  ~dump(fme_dict);
  fme_dict~udict_set(256, 302, dummy_slice);
  enumerate_dict(fme_dict);
  ~dump(909);
  enumerate_dict(results.at(0));
  cell c = compose(results);
  ~dump(c);
  ~dump(99);
  return (9,9);
}