{-
  In TON there is a limit on the size of the external message which can be sent equal to 64 kB. Sometimes it is necessary to send a larger
   message; it requires the onchain construction of one message from multiple smaller parts. Your task is to create such construction contract.
  In particular, a contestant needs to develop a FunC contract with two features:
    a) it has get_method "decomposite" for decomposition of large cell to parts: it accepts 1 cell (number_of_bits<1000000, 
    number_of_cells<4000 , depth<256) and 1 address and returns tuple of cells (each of which has less than 1000 distinct cells
     and 40000 bits total), those cells will be transformed to slice and sent as internal message body to the contract.
    b) recv_internal should handle those internal messages from get-method described above and upon receiving last one, send 
    initial large cell to the address (coins amount 0, mode 0). For simplicity, it is guaranteed that messages will be sent 
    exactly in the order in which they were in decomposite output and no other messages will be sent in between.
  Note, that initial state of contract storage will be empty cell: cell with zero bits and refs.
-}

;; testable
() recv_internal (slice body) {
}

tuple store_address_to_tupleidx_and_hash(builder curr_address, int hash_key, int tuple_idx, tuple final_result){
  cell addr_map = final_result.at(0);
  slice curr_address_sl = curr_address.end_cell().begin_parse();
  int addr_int_rep = curr_address_sl~load_uint(slice_bits(curr_address_sl));
  addr_map~udict_set_ref(256, addr_int_rep, begin_cell().store_int(tuple_idx, 8).store_int(hash_key, 256).end_cell());
  tuple updated_tuple = empty_tuple(); updated_tuple~tpush(addr_map); int ct = 1;
  while (ct < 255){
    updated_tuple~tpush(final_result.at(ct)); ct += 1;
  }
  return updated_tuple;
}

(int, tuple) store_key_to_slice(int hash_key, slice slice_to_add, int tuple_idx_hint, tuple final_result){
  cell cell_cand = final_result.at(tuple_idx_hint);
  (cell cell_stats, _) = udict_get_ref?(cell_cand, 256, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
  slice cell_stats_sl = cell_stats.begin_parse();
  int bit_ct = cell_stats_sl~load_uint(16);   ;; max 40,000 (max container 65535)
  int cell_ct = cell_stats_sl~load_uint(10);  ;; max 1,000 cells (max container 1023)
  int verified_full = cell_stats_sl~load_uint(1);   ;; boolean (uint 0 or 1)
  int tuple_idx = tuple_idx_hint;
  if ((bit_ct >= 37500) | (cell_ct >= 995)) {
    ;; this cell probably near full, confirm, then switch
    (int compute_cell_ct, int compute_bits_ct, int compute_ref_ct) = compute_data_size(cell_cand, 1000);
    if ((compute_bits_ct >= 37500) | (compute_cell_ct >= 995)){
      ;; this cell is definitely full, switch
      verified_full = 1; tuple_idx_hint += 1;
      (tuple_idx, final_result) = store_key_to_slice(hash_key, slice_to_add, tuple_idx_hint, final_result);
    } else { 
      ;; we ok bruh, do your thing
      int slice_bit_ct = slice_bits(slice_to_add); bit_ct += slice_bit_ct; cell_ct += 1;
      cell_cand~udict_set_ref(256, hash_key, begin_cell().store_slice(slice_to_add~load_bits(slice_bit_ct)).end_cell());
    }
  } else {
    ;; this cell is definitely able to take new cell, no need to check
    int slice_bit_ct = slice_bits(slice_to_add); bit_ct += slice_bit_ct; cell_ct += 1;
    cell_cand~udict_set_ref(256, hash_key, begin_cell().store_slice(slice_to_add~load_bits(slice_bit_ct)).end_cell());
  }
  ;; update tuple stats
  cell upd_tuple_stats = begin_cell().store_uint(bit_ct, 16).store_uint(cell_ct, 10).store_uint(verified_full, 1).end_cell();
  cell_cand~udict_set_ref(256, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, upd_tuple_stats);
  ;; replace element in final_result
  int ct = 0; tuple updated_tuple = empty_tuple();
  while (ct < 255){
    if (ct == tuple_idx){
      updated_tuple~tpush(cell_cand);
    } else {
      updated_tuple~tpush(final_result.at(ct));
    } ct += 1;
  }
  return (tuple_idx, updated_tuple);
}

(int, tuple) add_to_tuple(slice slice_to_add, builder curr_address, int tuple_idx_hint, tuple final_result) {
  int slice_bit_ct = slice_bits(slice_to_add); int remainder = slice_bit_ct % 8; slice slice_to_hash = slice_to_add;
  int hash_key = -1;
  if (remainder){
    int MOD = 57896044618658097711785492504343953926634992332820282019728792003956564819949;
    slice slice_prfx = begin_cell().store_uint(0, 8 - remainder).store_slice(slice_to_hash~load_bits(remainder)).end_cell().begin_parse();
    hash_key = (string_hash(slice_prfx) % MOD) + (string_hash(slice_to_hash) % MOD);
  }
  hash_key = string_hash(slice_to_hash);  ;; Hashkey for slice to add
  (int tuple_idx, final_result) = store_key_to_slice(hash_key, slice_to_add, tuple_idx_hint, final_result);
  final_result = store_address_to_tupleidx_and_hash(curr_address, hash_key, tuple_idx, final_result);
  return (tuple_idx, final_result);
}

(int, tuple) cycle_cell(cell curr_cell, builder curr_address, int tuple_idx_hint, tuple final_result){   ;; initialize final_result with stats
  slice curr_cell_slice = curr_cell.begin_parse();    ;; use slice_hash, pad to 8-bit, no refs
  (tuple_idx_hint, final_result) = add_to_tuple(curr_cell_slice, curr_address, tuple_idx_hint, final_result);
  int children_count = slice_refs(curr_cell_slice);
  if (children_count > 0){
    int ct = 0;
    while (ct < children_count) {
      cell child_cell = curr_cell_slice~load_ref();
      builder child_address = curr_address.store_uint(ct, 2);
      (tuple_idx_hint, final_result) = cycle_cell(child_cell, child_address, tuple_idx_hint, final_result);
      ct += 1;
    }
  }
  return (tuple_idx_hint, final_result);
}

;; testable
tuple decomposite (cell big_cell, slice destination_address) method_id {
  return empty_tuple();
}

(int, int) fme (int a, int b) method_id {
  ;; cell a = begin_cell().store_uint(8, 8).store_uint(0, 8).store_ref(begin_cell().store_uint(8, 8).end_cell()).end_cell();
  ;; slice sl = a.begin_parse();
  ;; ~dump(sl);
  ;; ~dump(sl~load_bits(16));
  ;; ~dump(string_hash(sl));
  ;; ~dump(sl);
  ;; ~dump([a.begin_parse().load_uint(16)]);
  tuple a = empty_tuple();
  a~tpush(10); a~tpush(15); a~tpush(20); a~tpush(25);
  ~dump(a);
  
  return (9,9);
}